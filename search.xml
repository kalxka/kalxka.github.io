<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>datastructure(2)</title>
      <link href="/2023/03/27/datastructure-2/"/>
      <url>/2023/03/27/datastructure-2/</url>
      
        <content type="html"><![CDATA[<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="堆的基本存储"><a href="#堆的基本存储" class="headerlink" title="堆的基本存储"></a>堆的基本存储</h2><p>1.概念：通常看作一颗完全二叉树的数组对象<br>（满二叉树是每层结点数都最大，完全二叉树是最后一层可以不满但是从左到右连续）<br>2.性质：</p><ul><li>总是一颗完全二叉树</li><li>堆中某个节点值总是不大于或不小于其父节点的值</li><li>利用二叉树结构维护一组数据</li></ul><p>3.适用：通常用于动态分配和释放程序所使用的对象<br>4.解释：</p><ul><li>最大堆：结点的值都小于等于父节点</li><li>最小堆：结点的值都大于等于父节点</li><li>给节点标号：用数组存储二叉堆，标号是数组的索引</li></ul><p>5.规律：<br>当前元素索引为i，则</p><ul><li>parent(i)&#x3D;i&#x2F;2</li><li>left child(i)&#x3D;2*i</li><li>right child(i)&#x3D;2*i+1</li></ul><p>6.代码:(构造空堆)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">package maxHeap;</span><br><span class="line"></span><br><span class="line">public class MaxHeap&lt;T&gt; &#123;//泛型&lt;T&gt;传递什么数据返回什么数据</span><br><span class="line">private T[] data;</span><br><span class="line">private int count;</span><br><span class="line">//构造函数，构造一个空堆，容纳capacity个元素</span><br><span class="line">public MaxHeap(int capacity) &#123;</span><br><span class="line">data=(T[])new Object[capacity+1];</span><br><span class="line">count=0;</span><br><span class="line">&#125;</span><br><span class="line">//返回堆中元素个数</span><br><span class="line">public int size() &#123;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line">//返回布尔值，堆中是否为空</span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return count==0;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">MaxHeap&lt;Integer&gt; maxHeap=new MaxHeap&lt;Integer&gt;(100);</span><br><span class="line">System.out.println(maxHeap.size());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆添加元素"><a href="#堆添加元素" class="headerlink" title="堆添加元素"></a>堆添加元素</h2><p>1.实现：shift up 向一个最大堆中添加元素<br>2.基本原理：元素添加到最后一个叶子结点上，跟父节点进行比较，大于父节点就交换，直到不再大于父节点，称为最大堆的shift up<br>3.代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package heapShiftUp;</span><br><span class="line">//&lt;T extends Comparable&gt; 表示定义了一个泛型类型参数T，要求它必须是实现了Comparable接口的类或接口。这个限制使得我们可以在使用泛型类型时，对其进行排序等操作，提高代码的可重用性和灵活性。</span><br><span class="line">public class HeapShiftUp&lt;T extends Comparable&gt; &#123;</span><br><span class="line">protected T[] data;</span><br><span class="line">protected int count;</span><br><span class="line">protected int capacity;</span><br><span class="line"></span><br><span class="line">public HeapShiftUp(int capacity) &#123;//构造函数，构造一个空堆，可容纳capacity个元素</span><br><span class="line">data=(T[])new Comparable[capacity+1];</span><br><span class="line">count=0;</span><br><span class="line">this.capacity=capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int size() &#123;//返回堆中元素个数</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isEmpty() &#123;//返回布尔值，表示堆中是否为空</span><br><span class="line">return count==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void insert(T item) &#123;//向最大堆中插入元素item</span><br><span class="line">if((count+1)&lt;=capacity) &#123;</span><br><span class="line">data[count+1]=item;</span><br><span class="line">count ++;</span><br><span class="line">shiftUp(count);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(int i,int j) &#123;</span><br><span class="line">T t=data[i];</span><br><span class="line">data[i]=data[j];</span><br><span class="line">data[j]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shiftUp(int k) &#123;</span><br><span class="line">while(k&gt;1&amp;&amp;data[k/2].compareTo(data[k])&lt;0)&#123;</span><br><span class="line">swap(k,k/2);</span><br><span class="line">k/=2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">HeapShiftUp&lt;Integer&gt; heapShiftUp=new HeapShiftUp&lt;Integer&gt;(100);</span><br><span class="line">int N=50;</span><br><span class="line">int M=100;</span><br><span class="line">for(int i=0;i&lt;N;i++) &#123;</span><br><span class="line">heapShiftUp.insert(new Integer((int)(Math.random()*M)));</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(heapShiftUp.size());</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆取出元素"><a href="#堆取出元素" class="headerlink" title="堆取出元素"></a>堆取出元素</h2><p>1.实现：shift down 从一个最大堆中取出一个元素，取出根节点后，如何填补最大堆<br>2.基本原理：<br>第一步：将数组最后一位元素放到根节点，比子节点小则和相对更大的子节点交换<br>第二步：继续和孩子结点比较，直到比孩子节点大为止<br>3.代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package heapShiftDown;</span><br><span class="line"></span><br><span class="line">public class HeapShiftDown&lt;T extends Comparable&gt; &#123;</span><br><span class="line">protected T[] data;</span><br><span class="line">protected int capacity;</span><br><span class="line">protected int count;</span><br><span class="line">// 构造函数, 构造一个空堆, 可容纳capacity个元素</span><br><span class="line">public HeapShiftDown(int capacity) &#123;</span><br><span class="line">data=(T[])new Comparable[capacity+1];//这里+1是因为data[0]是空的，去掉0位，只能装capacity个元素</span><br><span class="line">count=0;</span><br><span class="line">this.capacity=capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int size() &#123;</span><br><span class="line">return count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean isEmpty() &#123;</span><br><span class="line">return count==0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void insert(T item) &#123;</span><br><span class="line">if((count+1)&lt;=capacity) &#123;</span><br><span class="line">data[count+1]=item;</span><br><span class="line">count ++;</span><br><span class="line">shiftUp(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">//从最大堆中取出堆顶元素，即堆中存储的最大元素</span><br><span class="line">public T extractMax() &#123;</span><br><span class="line">assert count&gt;0;</span><br><span class="line">T ret=data[1];</span><br><span class="line">swap(1,count);</span><br><span class="line">count --;</span><br><span class="line">shiftDown(1);</span><br><span class="line">return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public T getMax() &#123;</span><br><span class="line">assert(count&gt;0);</span><br><span class="line">return data[1];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shiftUp(int k) &#123;</span><br><span class="line">while(k&gt;1&amp;&amp;data[k/2].compareTo(data[k])&lt;0) &#123;</span><br><span class="line">swap(k,k/2);</span><br><span class="line">k=k/2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void shiftDown(int k) &#123;</span><br><span class="line">while(2*k&lt;=count) &#123;//找子节点</span><br><span class="line">int j=2*k;//此轮循环中，data[j]和data[k]交换位置</span><br><span class="line">if((j+1) &lt;=count&amp;&amp;data[j+1].compareTo(data[j])&gt;0) &#123;//比较两个子节点大小</span><br><span class="line">j ++;</span><br><span class="line">&#125;</span><br><span class="line">if(data[k].compareTo(data[j])&gt;=0) &#123;//父节点大于子节点时退出循环</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">swap(k,j);</span><br><span class="line">k=j;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(&quot;ShiftDown结束&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void swap(int i,int j) &#123;</span><br><span class="line">T t=data[i];</span><br><span class="line">data[i]=data[j];</span><br><span class="line">data[j]=t;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">HeapShiftDown&lt;Integer&gt; heapShiftDown=new HeapShiftDown(100);</span><br><span class="line">int N=100;//堆中元素个数</span><br><span class="line">int M=100;//堆中元素取值范围[0,M)</span><br><span class="line">for(int i=0;i&lt;N;i++) &#123;</span><br><span class="line">heapShiftDown.insert(new Integer((int)(Math.random()*M)));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">Integer[] arr=new Integer[N];</span><br><span class="line">//将最大堆中的数据用extractMax取出放入数组，顺序是从大到小排列的</span><br><span class="line">for(int i=0;i&lt;N;i++) &#123;</span><br><span class="line">arr[i]=heapShiftDown.extractMax();</span><br><span class="line">System.out.println(arr[i]+&quot; &quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for( int i = 1 ; i &lt; N ; i ++ )</span><br><span class="line">assert arr[i-1] &gt;= arr[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>datastructure(1)</title>
      <link href="/2023/03/27/datastructure-1/"/>
      <url>/2023/03/27/datastructure-1/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构基础"><a href="#数据结构基础" class="headerlink" title="数据结构基础"></a>数据结构基础</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>处理大量的数据的搜索，排序和查找</p><h2 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h2><ul><li>栈：特殊线性表，只能在表的固定端进行数据结点插入删除</li><li>队列：特殊线性表，表一端插入一端删除</li><li>数据：聚合数据类型，相同类型若干变量有序组织在一起</li><li>链表：链式存储结构，物理上不连续</li><li>树：非线性结构</li><li>图：非线性结构</li><li>堆：特殊的树，一般二叉堆</li><li>散列表：取记录，F（T）的存储位置直接取，而不是通过比较</li></ul><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><ul><li>检索：给值找结点</li><li>插入：加结点</li><li>删除：删结点</li><li>更新：改结点值</li><li>排序：排结点</li></ul><h1 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h1><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>1.概念：适用少量元素。将一个记录插入到已经排好序的有序表。<br>2.实现：双层循环，外层对除了第一个元素外的所有元素，内层对待插入位置进行查找。<br>3.说明：假设前n-1（n&gt;&#x3D;2)个数已经排好序将第n个数插入到前面已经排好的序列中，找到自己位置，使第n个元素也排好<br>4.时间复杂度：排一个数比n-1次，则O(n),排整个数组(n-1)*n,则O(n^2)。<br>5.代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package insertionSort;</span><br><span class="line"></span><br><span class="line">public class InsertionSort &#123;</span><br><span class="line">public static void sort(Comparable[] arr) &#123;//排序接口 </span><br><span class="line">int n=arr.length;</span><br><span class="line">for(int i=0;i&lt;n;i++) &#123;</span><br><span class="line">for(int j=i;j&gt;0;j--) &#123;//和前面的元素比较</span><br><span class="line">if(arr[j].compareTo(arr[j-1])&lt;0) &#123;//小于前一个数</span><br><span class="line">swap(arr,j,j-1);</span><br><span class="line">&#125;</span><br><span class="line">else</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(Object[] arr,int i,int j) &#123;</span><br><span class="line">Object t=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">arr[j]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">int N=2000;</span><br><span class="line">Integer[] arr=SortTestHelper.generateRandomArray(N, 0, 10000);</span><br><span class="line">InsertionSort.sort(arr);</span><br><span class="line">for(int i=0;i&lt;arr.length;i++)</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">System.out.println(&#x27; &#x27;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>1.概念：适用中等规模数据，改进了插入排序，比较一定间隔的元素，直到只比较相邻元素的最后一趟排序为止。<br>2.实现：增量gap&#x3D;length&#x2F;2，缩小增量gap&#x3D;gap&#x2F;2<br>    比如8个元素，<br>    第一次增量为4，1和5，2和6，3和7，4和8相比较，得到四组排序<br>    第二次增量为2，1和357，2和468相比较，得到两组排序结果<br>    第三次增量为1（最后一次），直接排<br>    比插入排序多一个增量的循环<br>3.时间复杂度：O(n^1.3-2)<br>4.代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package shellSort;</span><br><span class="line"></span><br><span class="line">public class ShellSort &#123;</span><br><span class="line"></span><br><span class="line">public static void ShellSort(Comparable[] arr) &#123;</span><br><span class="line">int j;</span><br><span class="line">for(int gap=arr.length/2;gap&gt;0;gap/=2) &#123;//求出增量gap</span><br><span class="line">for(int i=gap;i&lt;arr.length;i++) &#123;</span><br><span class="line">Comparable tmp=arr[i];//临时变量记住arr[i]的值</span><br><span class="line">for(j=i;j&gt;=gap&amp;&amp;tmp.compareTo(arr[j-gap])&lt;0;j-=gap) &#123;</span><br><span class="line">arr[j]=arr[j-gap];//如果arr[j]比arr[j-gap]小，就把[j-gap]值给它</span><br><span class="line">&#125;</span><br><span class="line">arr[j]=tmp;//这里j是每组排序中最前的那个，把临时值给它，这个不会错的，如果交换了，那这里刚好没有值，没交换的话，相当于把值再给它一次</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">int N=2000;</span><br><span class="line">Integer[] arr=SortTestHelper.generateRandomArray(N, 0, 10000);</span><br><span class="line">ShellSort.ShellSort(arr);</span><br><span class="line">for(int i=0;i&lt;N;i++) &#123;</span><br><span class="line">System.out.println(arr[i]);</span><br><span class="line">System.out.println(&#x27; &#x27;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>1.概念：采用分治，有序子序列合并，先使子序列有序，再使子序列间有序，合两个子序列即二路归并<br>2.实现：合并两个已排序数组，输入数组A和B，输出数组C<br>    i,j,k对应数组开端<br>    A[i]和B[j]中较小者拷贝到C[k]中，相关计数器+1，两个数组其中一个输入完，将另外一个数组拷入C中<br>3.时间复杂度:n个记录时，进行log2n轮归并即logn，所以O(nlogn)<br>4.迭代法：</p><ul><li>申请空间，大小为两个已排列序列之和，存放合并后序列</li><li>设定两个指针，初位置分别两序列起始位置</li><li>比较两指针指向元素大小，选择较小的放入合并序列，并移动该指针</li><li>重复上一步直到其中一指针到达序列尾</li><li>将另一序列剩下元素直接复制到合并序列</li></ul><p>5.递归法：</p><ul><li>序列每两个相邻数字进行归并，排序后每个序列含两个元素</li><li>将上述序列再次归并，每个序列包含四个元素</li><li>一直重复，直到所有元素排序完毕</li></ul><p>6.代码（递归法）:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">package mergeSort;</span><br><span class="line"></span><br><span class="line">import java.util.Arrays;</span><br><span class="line"> //将arr[l...mid]和arr[mid+1...r]进行归并</span><br><span class="line">public class MergeSort &#123;</span><br><span class="line"></span><br><span class="line">public static void merge(Comparable[] arr,int l,int mid,int r) &#123;</span><br><span class="line">Comparable[] aux=Arrays.copyOfRange(arr, l, r+1);//返回一个长度为r+1-l的数组，元素从数组arr中从下标0开始复制，剩下的值为0，理解为把原数组复制过去</span><br><span class="line">//初始化，i指向左半部分的起始索引位置l，j指向右半部分起始索引位置mid+1</span><br><span class="line">int i=l,j=mid+1;</span><br><span class="line">for(int k=l;k&lt;=r;k++) &#123;</span><br><span class="line">if(i&gt;mid) &#123; //如果左半部分元素已经处理完毕</span><br><span class="line">arr[k]=aux[j-l];//这里采用j-l是因为，l，r可能是从数组中间取得，而aux对应的下标还是从0开始，j-l得到这是数组中第几个元素</span><br><span class="line">j++;//相当于指针右移</span><br><span class="line">&#125;</span><br><span class="line">else if(j&gt;r) &#123;//如果右半部分元素已经处理完毕</span><br><span class="line">arr[k]=aux[i-l];//这里采用i-l是因为，l，r可能是从数组中间取得，而aux对应的下标还是从0开始，i-l得到这是数组中第几个元素</span><br><span class="line">i++;//相当于指针右移</span><br><span class="line">&#125;</span><br><span class="line">else if(aux[i-l].compareTo(aux[j-l])&lt;0)  &#123;//左半元素小于右半元素，选左半元素</span><br><span class="line">arr[k]=aux[i-l];</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;//左半部分元素大于等于右半部分元素，选右半部分元素</span><br><span class="line">arr[k]=aux[j-l];</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">//递归使用归并排序，对arr[l...r]的范围进行排序</span><br><span class="line">public static void sort(Comparable[] arr,int l,int r) &#123;//递归法</span><br><span class="line">if(l&gt;=r) &#123;//无法排序</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int mid=(l+r)/2;</span><br><span class="line">sort(arr,l,mid);</span><br><span class="line">sort(arr,mid+1,r);</span><br><span class="line">//对于arr[mid]&lt;=arr[mid+1]的情况，不进行merge</span><br><span class="line">//对近乎有序的数组十分有效，对一般情况，有一定性能损失</span><br><span class="line">if(arr[mid].compareTo(arr[mid+1])&gt;0) &#123;//如果数组mid&gt;mid+1的值，归并</span><br><span class="line">merge(arr,l,mid,r);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] arr) &#123;</span><br><span class="line">int n=arr.length;</span><br><span class="line">sort(arr,0,n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">int N=1000;</span><br><span class="line">Integer[] arr=SortTestHelper.generateRandomArray(N, 0, 10000);</span><br><span class="line">sort(arr);</span><br><span class="line">SortTestHelper.printArray(arr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机化快速排序"><a href="#随机化快速排序" class="headerlink" title="随机化快速排序"></a>随机化快速排序</h2><p>1.概念：通过一趟排序将数据分成独立两部分，其中一部分所有数据都比另一部分数据小，再对这两部分快速排序，递归实现。（和归并一样，分治递归）<br>2.时间复杂度：O(nlogn)（分治递归的常见时间复杂度）<br>3.实现：</p><ul><li>在一个数组中选择一个基点，把它挪到正确位置，前面小于它，后面大于它，从前往后遍历和逐一比较实现</li><li>这个基点是随机选择的，就是随机化快速排序</li><li>也有头元素作为基准数快排和尾元素作为基准数快排</li></ul><p>4.优点:非常快速地处理上万个数据<br>5.代码:(随机元素快排)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">package quickSort;</span><br><span class="line">public class QuickSort &#123;</span><br><span class="line">//对arr[l...r]部分进行partition</span><br><span class="line">//返回p,使得arr[l...p-1]&lt;arr[p];arr[p+1...r]&gt;arr[p]，只能保证左边一定小，右边一定大，但不一定顺序</span><br><span class="line">public static int partition(Comparable[] arr,int l,int r) &#123;</span><br><span class="line">//随机选一个数据和起始点数据交换</span><br><span class="line">swap(arr,l,(int)(Math.random()*(r-l+1))+l);//如果不加这一步就是头元素基准数快排</span><br><span class="line">Comparable v=arr[l];//基准数的值赋给一个变量v</span><br><span class="line">//arr[l+1...j]&lt;v;arr[j+1...i]&gt;v</span><br><span class="line">int j=l;//记录基准数位置,每趟排序基准数位置会变化</span><br><span class="line">for(int i=l+1;i&lt;=r;i++) &#123;//从第二个元素开始与逐一比较</span><br><span class="line">if(arr[i].compareTo(v)&lt;0) &#123;//找到比基准点小的元素</span><br><span class="line">j++;//随机点位置记录后移一位</span><br><span class="line">swap(arr,j,i);//将这个小数放在基准数右边</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr,l,j);//将基准数换到记录好的位置上</span><br><span class="line">return j;//j代表此时这个元素在第几位</span><br><span class="line">&#125;</span><br><span class="line">//递归实现快排</span><br><span class="line">public static void sort(Comparable[] arr,int l,int r) &#123;</span><br><span class="line">if(l&gt;=r) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int p=partition(arr,l,r);</span><br><span class="line">sort(arr,l,p-1);</span><br><span class="line">sort(arr,p+1,r);</span><br><span class="line">&#125;</span><br><span class="line">//简化函数</span><br><span class="line">public static void sort(Comparable[] arr) &#123;</span><br><span class="line">int n=arr.length;</span><br><span class="line">sort(arr,0,n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(Object[] arr,int i,int j) &#123;</span><br><span class="line">Object t=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">arr[j]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">int N=1000;</span><br><span class="line">Integer[] arr=SortTestHelper.generateRandomArray(N, 0, 10000);</span><br><span class="line">sort(arr);</span><br><span class="line">SortTestHelper.printArray(arr);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双路快速排序"><a href="#双路快速排序" class="headerlink" title="双路快速排序"></a>双路快速排序</h2><p>1.概念：有两个索引值（i,j）来遍历数组，小于v放在i左边，大于v放在j右边<br>2.适用：随机化快速排序对于含大量重复元素的数组比较乏力，子数组长度极度不平衡，这时采用双路快速排序<br>3.实现：</p><ul><li>小于等于v放在i指向位置左边</li><li>大于等于v放在i指向位置右边</li></ul><p>4.代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">package quickSort2Ways;</span><br><span class="line">public class QuickSort2Ways &#123;</span><br><span class="line">public static int partition(Comparable[] arr,int l,int r) &#123;</span><br><span class="line">swap(arr,l,(int)(Math.random()*(r-1+l))+l);//最后一个值返回的是l到r+1之间的随机整数</span><br><span class="line">Comparable v=arr[l];</span><br><span class="line"></span><br><span class="line">int i=l+1;int j=r;</span><br><span class="line">while(true) &#123;</span><br><span class="line">while(i&lt;=r&amp;&amp;arr[i].compareTo(v)&lt;0) &#123;</span><br><span class="line">i++;</span><br><span class="line">&#125;</span><br><span class="line">while(j&gt;=r&amp;&amp;arr[j].compareTo(v)&gt;0) &#123;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">if(i&gt;j)</span><br><span class="line">break;</span><br><span class="line">swap(arr,i,j);</span><br><span class="line">j++;</span><br><span class="line">j--;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr,l,j);</span><br><span class="line">return j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] arr,int l,int r) &#123;//递归实现快排</span><br><span class="line">if(l&gt;=r) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">int p=partition(arr,l,r);</span><br><span class="line">sort(arr,l,p-1);</span><br><span class="line">sort(arr,p+1,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(Object[] arr,int i,int j) &#123;</span><br><span class="line">Object t=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">arr[j]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] arr) &#123;</span><br><span class="line">int n=arr.length;</span><br><span class="line">sort(arr,0,n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main() &#123;</span><br><span class="line">int N=200000;</span><br><span class="line">Integer[] arr=SortTestHelper.generateRandomArray(N, 0, 10000);</span><br><span class="line">sort(arr);</span><br><span class="line">SortTestHelper.printArray(arr);</span><br><span class="line">//测试几乎秒出结果，可以看出双路快排效率之高，一秒内处理100万量级数据</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三路快速排序"><a href="#三路快速排序" class="headerlink" title="三路快速排序"></a>三路快速排序</h2><p>1.概念：双路快排的改进，把需要排序的数据分成三部分，小于v，等于v，大于v，v为标定值，等于v的数据下次递归中不再需要排序。<br>2.适用：处理大量重复元素的数组<br>3.实现：</p><ul><li>索引i,It,gt</li><li>arr[l]a&#x3D;v;rr[l+1,it]&lt;v;arr[lt+1,i-1]&#x3D;v;arr[gt,r]&gt;v</li><li>当前处理元素等于v，索引i后移一位</li><li>当前处理元素小于v，索引it和i都后移一位</li><li>当前处理元素大于v，索引gt前移一位</li><li>i&#x3D;gt时，结束遍历，arr[l]和arr[it]交换</li><li>&lt;v   lt  &#x3D;&#x3D;v  gt  &gt;v</li></ul><p>4.代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">package quickSort3Ways;</span><br><span class="line"></span><br><span class="line">//递归使用快排</span><br><span class="line">public class QuickSort3Ways &#123;</span><br><span class="line">public static void sort(Comparable[] arr,int l,int r) &#123;</span><br><span class="line">if(l&gt;=r) &#123;</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line">//在arr[l,r]中随机选一个基准点</span><br><span class="line">swap(arr,l,(int)(Math.random()*(r-l+1))+l);</span><br><span class="line">Comparable v=arr[l];</span><br><span class="line"></span><br><span class="line">int lt=l;//基准点位置</span><br><span class="line">int gt=r+1;//最后一位</span><br><span class="line">int i=l+1;//基准点后一位</span><br><span class="line">//&lt;v  it   ==v   gt   &gt;v</span><br><span class="line">while(i&lt;gt) &#123;//遍历</span><br><span class="line">if(arr[i].compareTo(v)&lt;0) &#123;//比v小</span><br><span class="line">swap(arr,i,lt+1);//和=v区间第一个元素交换</span><br><span class="line">i++;//遍历下一个</span><br><span class="line">lt++;//&lt;v的索引后移</span><br><span class="line">&#125;</span><br><span class="line">else if(arr[i].compareTo(v)&gt;0) &#123;//比v大</span><br><span class="line">swap(arr,i,gt-1);//gt前最后一个元素交换</span><br><span class="line">gt--;//&gt;v的索引前移</span><br><span class="line">&#125;</span><br><span class="line">else &#123;//==v</span><br><span class="line">i++;//i索引后移</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(arr,l,lt);//基准值放入=v的区间</span><br><span class="line">sort(arr,l,lt-1);//递归</span><br><span class="line">sort(arr,gt,r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void swap(Object[] arr,int i,int j) &#123;</span><br><span class="line">Object t=arr[i];</span><br><span class="line">arr[i]=arr[j];</span><br><span class="line">arr[j]=t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void sort(Comparable[] arr) &#123;</span><br><span class="line">int n=arr.length;</span><br><span class="line">sort(arr,0,n-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">int N=5000;</span><br><span class="line">Integer[] arr=SortTestHelper.generateRandomArray(N, 0, 10000);</span><br><span class="line">SortTestHelper.printArray(arr);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th align="center">算法</th><th align="center">适用</th><th align="center">补充</th></tr></thead><tbody><tr><td align="center">插入排序</td><td align="center">少量元素</td><td align="center">双层循环</td></tr><tr><td align="center">希尔排序</td><td align="center">中等大小规模数据</td><td align="center">三层循环，增量</td></tr><tr><td align="center">归并排序</td><td align="center">数据量大且要求稳定性</td><td align="center">分治递归nlogn</td></tr><tr><td align="center">随机化快排</td><td align="center">快速处理百万量级数据</td><td align="center">分治递归nlogn</td></tr><tr><td align="center">双路快排</td><td align="center">百万量级数据且大量重复元素</td><td align="center">分治递归nlogn</td></tr><tr><td align="center">三路快排</td><td align="center">百万量级数据且大量重复元素</td><td align="center">分治递归nlogn</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android(1)</title>
      <link href="/2023/03/25/Android%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0-1/"/>
      <url>/2023/03/25/Android%E5%BC%80%E5%8F%91%E5%AD%A6%E4%B9%A0-1/</url>
      
        <content type="html"><![CDATA[<h1 id="应用程序组件"><a href="#应用程序组件" class="headerlink" title="应用程序组件"></a>应用程序组件</h1><ul><li><p>Activities:构成用户界面</p></li><li><p>Services：可以独立于Activity，处理与应用程序相关的后台处理</p></li><li><p>Broadcast Receivers：处理Android操作系统和应用程序之间的通信</p></li><li><p>Content Providers:为设备中存储的数据提供一个抽象层，实现数据共享，可以对别人访问数据的方式拥有完全的控制权</p></li><li><p>附加组件</p><ul><li><p>Fragments:Activity中用户界面的一部分</p></li><li><p>Views:绘制UI元素</p></li><li><p>Intents:系统消息，向应用程序发布时间，比如收到了短信，用户通过主菜单打开了Activity</p></li></ul></li></ul><h1 id="Android资源组织"><a href="#Android资源组织" class="headerlink" title="Android资源组织"></a>Android资源组织</h1><p>位于res&#x2F;目录的各个子目录下</p><blockquote><p>anim&#x2F; 定义属性动画的XML文件<br>color&#x2F; 定义颜色状态列表的XML文件<br>drawable&#x2F; 图像文件<br>layout&#x2F; 用户界面布局的XML文件<br>menu&#x2F; 应用程序菜单的XML文件<br>raw&#x2F; 原始形式保存的任意文件<br>xml&#x2F; 在此处保存运行时使用的各种配置文件<br>values&#x2F; 包含简单值的XML文件</p><blockquote><p>arrays.xml用于资源数组<br>integers.xml用于资源整数<br>bools.xml用于资源布尔值</p></blockquote></blockquote><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><h4 id="引用图片资源"><a href="#引用图片资源" class="headerlink" title="引用图片资源"></a>引用图片资源</h4><p>1.在布局xml（activity_main.xml）中以@drawable形式引入图片资源</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ImageView</span><br><span class="line">    android:layout_height=&quot;wrap_content&quot;</span><br><span class="line">    android:layout_width=&quot;wrap_content&quot;</span><br><span class="line">    android:src=&quot;@drawable/myimage&quot; /&gt;</span><br></pre></td></tr></table></figure><img decoding="async" src="/images/20230325.png" width="50%"><p>2.Java代码实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ImageView imageView = (ImageView) findViewById(R.id.myimageview);</span><br><span class="line">imageView.setImageResource(R.drawable.myimage);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android开发 </tag>
            
            <tag> md练习 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
